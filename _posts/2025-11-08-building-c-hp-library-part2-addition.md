---
layout: post
title: "从零构建C语言高精度算法库（二）：正整数加法实现"
date: 2025-11-08
---

在构建高精度算法库的旅程中，我们从**最基础**的正整数四则运算开始。

虽然当前只限于正整数，但这正是整个算法库的**基石**。

未来无论是扩展到有符号数还是浮点数，都需要建立在稳定可靠的整数运算之上。

大型代码库的**稳定性**，很大程度上取决于**底层架构**的设计质量。

## 选择合适的数字存储方案

在实现具体算法之前，我们需要确定高精度数的存储方式。经过对比分析，我选择了 **char数组 + 字符存储** 的方案，这主要基于以下几个考量：

### 对比其他存储方案

**vs 链表存储：**
- **内存效率**：char数组在内存中是连续分配的，相比链表的节点指针开销更小
- **访问性能**：数组支持随机访问，而链表只能顺序访问
- **缓存友好**：连续内存布局对CPU缓存更友好

**vs int数组压位存储：**
- **可读性**：char数组按十进制位存储，调试和输出都很直观
- **实现复杂度**：避免进制转换的复杂性，降低代码出错概率
- **兼容性**：可直接利用C语言的字符串处理函数

**综合优势：**
- 创建和初始化简单
- 输入输出自然（本身就是字符串形式）
- 单位存储一个数字，逻辑清晰
- 便于实现复杂的数学运算

***

# 核心实现：正整数加法

## 关键设计 - 数组反转函数

在实现加法之前，我们需要一个重要的**辅助函数**：`hp_flip`（数组反转函数）。

```c
char* hp_flip(char r[]) {
    int L = strlen(r);
    char temp;
    for (int i = 0; i < L - i - 1; i++) {
        temp = r[i];
        r[i] = r[L - i - 1];
        r[L - i - 1] = temp;
    }
    return r;
}
```
## 为什么需要反转数组？

回忆我们手算加法的过程：

- 从最右边（个位）开始对齐

- 从低位到高位逐位相加

- 处理进位时向高位传递

- 而数组的存储是左对齐的：

```text
数字 "123" 在数组中： ['1', '2', '3', '\0']
索引：0    1    2
通过反转数组，我们实现了与手算相同的对齐逻辑：
```
```text
反转后：['3', '2', '1', '\0']
个位对齐个位，十位对齐十位...
加法算法实现
```

***

```c
char* hp_add(char a[], char b[], char c[]) {
    hp_flip(a), hp_flip(b);
    int t = 0;  // 进位标志
    
    for (int i = 0; a[i] != '\0' || b[i] != '\0'; i++) {
        // 核心计算：逐位相加并处理空位
        c[i] = (a[i] + b[i] - '0' + t + 
                '0' * (a[i] == '\0') + '0' * (b[i] == '\0'));
        
        // 处理进位
        if (isdigit(c[i])) {  // 当前位不需要进位
            t = 0;
        } else {              // 当前位需要进位
            c[i] -= 10;
            t = 1;
            c[i + 1] = '1';   // 预置进位，巧妙的设计！
        }
    }
    
    hp_flip(a), hp_flip(b), hp_flip(c);
    return c;
}
```
## 算法亮点解析

1. 巧妙的进位预置设计
```c
c[i + 1] = '1';  // 关键设计！
```
这个设计的精妙之处在于：

当两个数字的各位没有计算完时，这个预置的'1'会被后续的正确结果**覆盖**

当两个数字全部计算完时，这个'1'就**代表**了最高位的进位

举例说明：

```text
计算 900 + 100：
反转后：a = "009", b = "001"
计算过程：
  第0位：9+0+0=9 → 无进位
  第1位：0+0+0=0 → 无进位  
  第2位：0+1+0=1 → 无进位
  第3位：预置的'1'保留 → 结果"1000"
反转后得到："0001" → 1000
```
2. 空位处理技巧
```c
'0' * (a[i] == '\0') + '0' * (b[i] == '\0')
```
这个表达式优雅地处理了数字位数不同的情况，当某个数字的当前位为空时，自动补'0'。

3. 数据保护原则
```c
hp_flip(a), hp_flip(b), hp_flip(c);  // 恢复原数组
```
函数内部虽然修改了原数组，但计算完成后立即恢复，确保不影响后续运算。这是库函数设计的**重要原则**：尽量保持数据的不可变性。

## 技术细节补充
字符与数字的转换
字符'0'\~'9'在ASCII中对应48\~57

c - '0' 将字符转换为数字

c + '0' 将数字转换为字符

边界情况考虑
  
两个零相加的特殊情况

***

## 总结
通过char数组存储和巧妙的算法设计，我们实现了一个高效可靠的高精度加法函数。

这个实现不仅功能正确，更重要的是为后续的减法、乘法、除法运算奠定了良好的架构基础。

当然按照以上方法构建的加法函数输入必须**标准**，数组内部也不能有**垃圾值**

诚然，边界检查和错误处理很重要

但是在基础代码构建时，建议先考虑核心功能的实现。代码开发中先构建出核心架构，在构建维护这套架构的**"免疫系统"**

***

在下一篇文章中，我们将基于加法的设计思路，实现高精度减法运算，并探讨如何处理负数的情况。
