---
layout: post
title: "从零构建C语言高精度算法库（五）：高精度除法实现"
date: 2025-12-11
---
# 从零构建C语言高精度算法库（五）：高精度除法实现

## 前言

在成功构建了加法、乘法的基石之后，我们迎来了四则运算的最终挑战：**高精度除法**。

除法是四则运算中最复杂的一环。它不仅需要乘法和减法作为基础，还涉及试商、比较、循环等复杂逻辑。

## 准备工作：比较函数的重要性
***

在进行除法运算前，我们需要一个关键的辅助工具：**比较函数**。它决定了我们何时进行除法、何时停止除法。


```c
int hp_cmp(char a[], char b[]) // 高精度比大小
{
    int La = strlen(a);
    int Lb = strlen(b);
    
    // 位数不同，位数多的数值大
    if (La > Lb) return 1;
    if (La < Lb) return -1;
    
    // 位数相同，逐位比较
    return strcmp(a, b);
}
```



**算法亮点：先比较位数**
这个简单而高效的设计基于一个重要数学事实：对于两个正整数，位数多的一定更大。只有当位数相同时，我们才需要逐位比较。这种两级判断策略大大减少了不必要的比较操作。

## 核心实现：模拟长除法的艺术
***

除法算法模拟了我们在纸上进行长除法的过程。回忆一下小学时的竖式除法：

1.  从被除数的高位开始，取足够的位数构成临时被除数
2.  估计商的一位，使得除数乘以这一位不大于临时被除数
3.  从临时被除数中减去乘积，得到新的临时被除数
4.  重复上述过程，直到处理完所有位数



```c
char* hp_div(char a[], char b[], char c[])
{
    // 边界检查：除数不能为0
    if (b[0] == '0') // 除数为0
    {
        return NULL;
    }
    
    // 特殊情况处理
    if (hp_cmp(a, b) < 0) // 被除数小于除数
    {
        c[0] = '0';
        return c;
    }
    if (hp_cmp(a, b) == 0) // 被除数等于除数
    {
        c[0] = '1';
        return c;
    }
    
    int La = strlen(a);
    int Lb = strlen(b);
    int diff = La - Lb; // 商的最大位数-1
    
    // 预计算乘法表：b的1-9倍
    char mul_table[10][N_MAX] = { 0 };
    for (int i = 1; i <= 9; i++)
    {
        char t[N_MAX] = { 0 };
        strcpy(mul_table[i], hp_mul_int(b, i, t));
    }
    
    // 初始化商数组为0（注意：只初始化前diff位）
    for (int i = 0; i < diff; i++)
    {
        c[i] = '0';
    }
    // 注意：c[diff]位不初始化，将在试商过程中写入
    // 这是算法的重要细节：最高位不预设为'0'，避免影响后续判断
    
    char A[N_MAX] = { 0 };
    strcpy(A, a); // 复制被除数，防止修改原数据
    
    // 核心算法：逐位试商
    for (int i = diff; i >= 0; i--) // 从最高位到最低位
    {
        for (int k = 9; k >= 1; k--) // 从9到1尝试商的值
        {
            char num[N_MAX] = { 0 };
            hp_mul10(mul_table[k], i, num); // num = b * k * 10^i
            
            // 情况1：恰好整除
            if (hp_cmp(A, num) == 0)
            {
                c[i] = k + '0'; // 设置商的当前位
                hp_flip(c);     // 反转商数组（从计算顺序转为显示顺序）
                return c;
            }
            
            // 情况2：临时被除数大于等于乘积
            if (hp_cmp(A, num) > 0)
            {
                c[i] = k + '0'; // 设置商的当前位
                
                // 从临时被除数中减去乘积
                char t[N_MAX] = { 0 };
                hp_sub(A, num, t);
                strcpy(A, t); // 更新临时被除数
                break; // 处理下一位
            }
        }
        // 如果从9到1都找不到合适的k，则该位为0（c[i]可能保持未初始化的随机值）
        // 因此，必须确保c[i]在进入循环前已被正确初始化
        // 对于i < diff的情况，已在循环前初始化为'0'
        // 对于i == diff的情况，要么找到k并赋值，要么永远不会执行到这里（因为至少k=1会成功）
    }
    
    hp_flip(c); // 反转商数组
    return c;
}
```



## 算法亮点解析：设计与技巧
***

### 1. 预计算乘法表的智慧



```c
char mul_table[10][N_MAX];
for (int i = 1; i <= 9; i++) {
    strcpy(mul_table[i], hp_mul_int(b, i, t));
}
```



这个设计与乘法中的思路一致，但在这里有了新的意义：

-   **避免重复计算**：在试商过程中，我们需要频繁计算`b × k`的值
-   **提高效率**：预计算后，每次试商只需查表，无需重复乘法
-   **支持快速位权计算**：配合`hp_mul10`函数，可以快速得到`b × k × 10^i`

### 2. 数组初始化的精妙设计


```c
for (int i = 0; i < diff; i++) {
    c[i] = '0';
}
// 注意：不初始化c[diff]位
```



这是一个重要细节：我们只初始化前`diff`位为'0'，最高位（`c[diff]`）留给试商过程写入。这样设计有两个原因：

1.  **避免前导零问题**：如果最高位恰好为0，反转后会导致商出现前导零
2.  **确保正确性**：至少会有一位商（因为a>b），最高位至少为1

### 3. 逐位试商的精妙过程

算法中最核心的部分是双重循环：

-   **外层循环**：`for (int i = diff; i >= 0; i--)`
    -   从商的最低位到最高位（对应从10^diff到10^0）
    -   这模拟了手算除法中"从高位到低位"的过程
-   **内层循环**：`for (int k = 9; k >= 1; k--)`
    -   从9到1尝试商的值
    -   找到最大的k使得`b × k × 10^i ≤ A`

**为什么从大到小尝试？**
因为我们希望商的每一位尽可能大，所以要找到最大的k满足条件。

### 4. 临时被除数的动态更新


```c
char A[N_MAX] = { 0 };
strcpy(A, a); // 初始化

// 在试商过程中更新
hp_sub(A, num, t);
strcpy(A, t);
```



这个变量`A`记录了每一步的剩余被除数，相当于手算除法中"拉下来"的新数字。

### 5. 位权处理的巧妙实现


```c
hp_mul10(mul_table[k], i, num); // num = b * k * 10^i
```



这里利用了`hp_mul10`函数的特性：在数字末尾添加i个0，相当于乘以10^i。这个简单的字符串操作实现了复杂的位权计算。

## 算法可视化：手算过程的代码映射

***

让我们通过`1234 ÷ 12`的例子，理解算法如何工作：


```
手算过程：
   102
  -----
12)1234
  -12
   ---
    34
   -24
   ---
    10  (余数)

代码执行过程：
diff = 4 - 2 = 2

初始化c数组：c[0]='0', c[1]='0' (c[2]未初始化)

第一步：i=2, k从9到1
  尝试k=1: b×1×10^2 = "1200" < "1234"
  c[2] = '1', A = "1234" - "1200" = "34"

第二步：i=1, k从9到1
  尝试k=2: b×2×10^1 = "240" > "34" → 不行
  尝试k=1: b×1×10^1 = "120" > "34" → 不行
  c[1]保持'0' (已在初始化时设为'0')

第三步：i=0, k从9到1
  尝试k=2: b×2×10^0 = "24" < "34"
  c[0] = '2', A = "34" - "24" = "10"

c数组：['2','0','1'] → 反转后"102" ✓
```

## 算法复杂度分析

该算法的时间复杂度主要取决于两个循环：

-   外层循环执行`diff+1`次
-   内层循环最多执行9次
-   每次循环内部涉及字符串比较和减法操作

总的时间复杂度约为O(n²)，其中n为商的位数。对于大多数应用场景，这个复杂度是可以接受的。

## 算法边界情况

算法已经考虑了几种边界情况：

1.  **除数为0**：返回NULL，表示错误
2.  **被除数小于除数**：直接返回0
3.  **被除数等于除数**：直接返回1
4.  **正常除法**：按上述算法计算

## 总结：算法库的完整闭环

通过实现除法，我们的高精度算法库完成了四则运算的最后一块拼图。回顾这一路：

1.  **加法**：构建了基础框架和数组反转设计
2.  **乘法**：引入了预计算和位权处理
3.  **除法**：综合运用了比较、乘法、减法，实现了最复杂的运算

除法算法的实现展现了算法设计的一个重要原则：**复杂问题可以分解为已知的简单问题**。

通过巧妙地组合比较、乘法和减法，我们构建出了看似复杂的除法运算。

------

**PS：**
其实早在一个月前刚写到高精度减法的时候，算法库都已经构建成功了

总共1500行代码，在正整数四则运算的基础上

用结构体封装，复杂的浮点数处理逻辑

完成了实数范围内加减乘除，整数阶乘次幂的运算

还包括开根号利用拉马鲁金公式计算圆周率100位之内。

开发速度远超写博客速度，代码已经上传我的个人仓库(https://github.com/WangZhengWei2007/High_precision_computing_project)

下一篇文章将总体总结这个高精度算法库，也算有始有终，完结撒花了。

虽然没人看 o(TヘTo)
