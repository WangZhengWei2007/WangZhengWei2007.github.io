---
layout: post
title: "从零构建C语言高精度算法库（三）：正整数减法实现"
date: 2025-11-10
---
# 从零构建C语言高精度算法库（三）：正整数减法实现

## 前言

在构建了高精度加法的坚实基础后，我们继续向减法这一重要运算迈进。

减法看似是加法的逆运算，但在实现细节上却有着独特的挑战：**借位处理**、**符号确定**、**前导零清理**等问题都需要精心设计。

与加法不同，减法运算可能产生**负数**结果，这为我们后续扩展有符号运算埋下了重要的**伏笔**。

***

## 减法算法的核心设计

### 符号预处理与大小比较

在开始计算之前，我们首先要确定两个数的大小关系：

```c
char* D;    // 指向较大的数
char* X;    // 指向较小的数  
int sign = 1; // 结果符号标记

if (hp_cmp(a, b) >= 0) {
    D = a; X = b;        // a ≥ b，结果为正
} else {
    D = b; X = a;        // a < b，结果为负
    sign = -1;
}
```

这种设计的巧妙之处在于：我们始终用大数减小数，避免了中间计算过程中出现负值，简化了借位逻辑。

### 字符串反转与对齐处理

与加法类似，我们采用反转字符串的方式从低位开始计算：

```c
hp_flip(D);  // 反转大数字符串
hp_flip(X);  // 反转小数字符串
精妙的逐位相减
减法的核心在于借位处理，我们通过一个简洁的表达式实现了自动补零和借位计算：
```

```c
int t = 0;  // 借位标志
for (int i = 0; D[i] != '\0'; i++) {
    c[i] = D[i] - X[i] + '0' + t - '0' * (X[i] == '\0');
    if (c[i] < '0') {
        c[i] += 10;     // 需要借位
        t = -1;         // 设置借位标志
    } else {
        t = 0;          // 重置借位标志
    }
}
```

这里的关键技巧 '0' * (X[i] == '\0') 实现了自动边界处理：当较小的数位数不足时，这个表达式会自动补上字符'0'，避免了繁琐的条件判断。

### 前导零的清理

由于结果是反转存储的，前导零出现在字符串的末尾：

```c
int LD = strlen(D);
for (int i = LD - 1; c[i] == '0' && i > 0; i--) {
    c[i] = '\0';  // 去除前导零，但至少保留一位
}
这个循环从结果末尾开始清理多余的零，同时确保即使结果为0也能保留最基本的'0'字符。

```

### 结果整理与符号添加

```c
hp_flip(c);  // 反转回正常顺序

// 为负数结果添加负号
if (sign == -1)
{
    int L = strlen(c);
    for (int i = L - 1; i >= 0; i--)
    {
        c[i + 1] = c[i];
    }
    c[0] = '-';
}
```

***

## 架构设计的深层思考

为什么**正整数**减法要支持**负数**结果？

这是一个值得深入探讨的**设计决策**。

从表面看，我们的函数处理的是正整数，似乎应该默认前者大于后者得到正数。

但实际上，这种"适度复杂"的设计体现了软件工程中的重要原则：

**为上层建筑奠定基础**

-有符号运算的依赖：未来实现有符号加减法时，可以直接调用这里的正整数减法

-避免功能重复：如果这里不支持负数，上层函数就需要重复实现类似的逻辑

-接口简洁性：保持函数接口的一致性，让调用者无需关心内部的大小关系

**功能与复杂度的平衡**

在基层函数设计中，我们追求的不是极致的简单，而是**功能完备性**与**代码可维护性**的**平衡**。

**适当**的复杂度提升如果能为上层带来显著的**便利**，这样的设计就是合理的。

***

## 完整代码实现

```c
char* hp_sub(char a[], char b[], char c[])
{
    char* D;
    char* X;
    int sign = 1;
    
    // 确定大小关系和符号
    if (hp_cmp(a, b) >= 0) {
        D = a;
        X = b;
    } else {
        D = b;
        X = a;
        sign = -1;
    }
    
    // 反转字符串，从低位开始计算
    hp_flip(D), hp_flip(X);
    
    // 逐位相减
    int t = 0;
    for (int i = 0; D[i] != '\0'; i++) {
        c[i] = D[i] - X[i] + '0' + t - '0' * (X[i] == '\0');
        if (c[i] < '0') {
            c[i] += 10;
            t = -1;
        } else {
            t = 0;
        }
    }
    
    // 清理前导零
    int LD = strlen(D);
    for (int i = LD - 1; c[i] == '0' && i > 0; i--) {
        c[i] = '\0';
    }
    
    // 恢复顺序并添加符号
    hp_flip(c);
    if (sign == -1) {
        int L = strlen(c);
        for (int i = L - 1; i >= 0; i--) {
            c[i + 1] = c[i];
        }
        c[0] = '-';
    }
    
    // 恢复原始数据
    hp_flip(D), hp_flip(X);
    return c;
}
```

***

## 总结

高精度减法的实现不仅考验我们对算法细节的把握，更考验我们对系统架构的**前瞻性**思考。

通过合理的设计，我们让这个基础函数具备了更强的**扩展性**，为后续有符号运算、乘法、除法等功能铺平了道路。

在构建算法库的过程中，每一个基础组件的设计都影响着整个系统的优雅程度。

***

## 后续

下一篇文章中，我们将继续探索高精度乘法的实现，那将是另一个充满挑战的旅程。
